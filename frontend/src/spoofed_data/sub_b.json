{"code": "// Implements a dictionary's functionality\n#include <stdbool.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n\n#define SIZE 1000000\n\n#include \"dictionary.h\"\n\n//define link\ntypedef struct node\n{\n    char word[LENGTH + 1];\n    struct node* next;\n}\nnode;\n\n\n// create hashtable\nnode* hashtable[SIZE] = {NULL};\nint hash(const char*);\n\nint dictionarySize = 0;\n\n\n\n\n// Returns true if word is in dictionary else false\nbool check(const char *word)\n{\n    char temp[LENGTH + 1];\n    int len = strlen(word);\n    for(int i = 0; i < len; i++)\n    {\n        temp[i] = tolower(word[i]);\n    }\n\n    temp[len] = '\\0';\n\n    // index of the array the word should be in\n    int index = hash(temp);\n\n    // if hashtable is empty at index, return false\n    if (hashtable[index] == NULL)\n    {\n        return false;\n    }\n\n    // create cursor to compare to word\n    node* cursor = hashtable[index];\n\n    // if hashtable is not empty at index, iterate through words and compare\n    while (cursor != NULL)\n    {\n        if (strcmp(temp, cursor->word) == 0)\n        {\n            return true;\n        }\n        cursor = cursor->next;\n    }\n\n    return false;\n}\n\n\n\n\n// Loads dictionary into memory, returning true if successful else false\nbool load(const char *dictionary)\n{\n     FILE* file = fopen(dictionary, \"r\");\n     if (file == NULL)\n     {\n         return false;\n     }\n\n    // create an array for word to be stored in\n    char word[LENGTH+1];\n\n    // scan through the file, loading each word into the hash table\n    while (fscanf(file, \"%s\\n\", word)!= EOF)\n    {\n        // increment dictionary size\n        dictionarySize++;\n\n        // allocate memory for new word\n        node* newWord = malloc(sizeof(node));\n\n        // put word in the new node\n        strcpy(newWord->word, word);\n\n        // find what index of the array the word should go in\n        int index = hash(word);\n\n        // if hashtable is empty at index, insert\n        if (hashtable[index] == NULL)\n        {\n            hashtable[index] = newWord;\n            newWord->next = NULL;\n        }\n\n        // if hashtable is not empty at index, append\n        else\n        {\n            newWord->next = hashtable[index];\n            hashtable[index] = newWord;\n        }\n    }\n\n    fclose(file);\n\n    return true;\n\n}\n\n\n\n\n// Returns number of words in dictionary if loaded else 0 if not yet loaded\nunsigned int size(void)\n{\n   if (dictionarySize > 0)\n    {\n        return dictionarySize;\n    }\n\n    // if dictionary hasn't been loaded, return 0\n    else\n        return 0;\n}\n\n// Unloads dictionary from memory, returning true if successful else false\nbool unload(void)\n{\n    // create a variable to go through index\n    int index = 0;\n\n    // iterate through entire hashtable array\n    while (index < SIZE)\n    {\n        // if hashtable is empty at index, go to next index\n        if (hashtable[index] == NULL)\n        {\n            index++;\n        }\n\n        // if hashtable is not empty, iterate through nodes and start freeing\n        else\n        {\n            while(hashtable[index] != NULL)\n            {\n                node* cursor = hashtable[index];\n                hashtable[index] = cursor->next;\n                free(cursor);\n            }\n\n            // once hashtable is empty at index, go to next index\n            index++;\n        }\n    }\n\n    // return true if successful\n    return true;\n\n}\n\n\n\n\n//hash function\nint hash (const char* word)\n{\n    int hash = 0;\n    int n;\n    for (int i = 0; word[i] != '\\0'; i++)\n    {\n        // alphabet case\n        if(isalpha(word[i]))\n            n = word [i] - 'a' + 1;\n\n        // comma case\n        else\n            n = 27;\n\n        //a << b\tbitwise operation\n        hash = ((hash << 3) + n) % SIZE;\n    }\n    return hash;\n}"}
